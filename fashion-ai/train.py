# -*- coding: utf-8 -*-
"""fashion-attribute-recognition.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QQ1iy3G5y0tdGDiOJvESMcIKv7jZTrgk
"""

from fastai.vision.all import *
import gc


PATH = "/research/dept8/fyp22/pah2203/AIST4010/project/datasets/Deepfashion/"
TRAIN_PATH = "/research/dept8/fyp22/pah2203/AIST4010/project/fashion-ai/clothes-categories/multilabel-train.csv"
TEST_PATH = "/research/dept8/fyp22/pah2203/AIST4010/project/fashion-ai/clothes-categories/multilabel-test.csv"
CLASSES_PATH = "/research/dept8/fyp22/pah2203/AIST4010/project/fashion-ai/clothes-categories/attribute-classes.txt"


train_df = pd.read_csv(TRAIN_PATH)
train_df.head()


def get_x(r): return PATH+r['image_name'].replace("(",")")
def get_y(r): return r['labels'].split(',')

def splitter(df):
    train = df.index[df['is_valid']==0].tolist()
    valid = df.index[df['is_valid']==1].tolist()
    return train,valid

dblock = DataBlock(blocks=(ImageBlock, MultiCategoryBlock),
                   splitter=splitter,
                   get_x=get_x, 
                   get_y=get_y,
                   item_tfms=RandomResizedCrop(224, min_scale=0.8),
                   batch_tfms=aug_transforms())

dls = dblock.dataloaders(train_df, num_workers=5, device=torch.device('cuda'))

dsets = dblock.datasets(train_df)

dsets.train[0]

def accuracy_multi(inp, targ, thresh=0.5, sigmoid=True):
    "Compute accuracy when `inp` and `targ` are the same size."
    if sigmoid: inp = inp.sigmoid()
    return ((inp>thresh)==targ.bool()).float().mean()

number_of_classes = len(dsets.train[0][1])
fake_prediction = torch.tensor([[0.0] * number_of_classes])
fake_prediction

target = dsets.train[0][1].reshape(1,-1)
accuracy_multi(fake_prediction, target,  thresh=0.5, sigmoid=True)

from sklearn.metrics import fbeta_score
fbeta_score(fake_prediction, target, beta=2, average='samples')

# create a random prediction
import random
random_list = [0.0]*int(number_of_classes/2) + [1.0]*int(number_of_classes/2)
random.shuffle(random_list)
fake_prediction = torch.tensor([random_list])
fake_prediction

fbeta_score(fake_prediction, target, beta=2, average='samples')

# create a perfect prediction where prediction=target
fbeta_score(target, target, beta=2, average='samples')

dsets.train[0]

dls.vocab

class LabelSmoothingBCEWithLogitsLossFlat(BCEWithLogitsLossFlat):
    def __init__(self, eps:float=0.1, **kwargs):
        self.eps = eps
        super().__init__(thresh=0.2, **kwargs)
    
    def __call__(self, inp, targ, **kwargs):
        # https://www.kaggle.com/c/siim-isic-melanoma-classification/discussion/166833#929222
        targ_smooth = targ.float() * (1. - self.eps) + 0.5 * self.eps
        return super().__call__(inp, targ_smooth, **kwargs)
    
    def __repr__(self):
        return "FlattenedLoss of LabelSmoothingBCEWithLogits()"

metrics=[FBetaMulti(2.0, 0.2, average='samples'), partial(accuracy_multi, thresh=0.2)]

wd      = 5e-7 #weight decay parameter
opt_func = partial(ranger, wd=wd)

learn = vision_learner(dls, resnet50, loss_func=LabelSmoothingBCEWithLogitsLossFlat(),
            metrics=metrics, opt_func=opt_func).to_fp16()

learn.fine_tune(10)
learn.save('trained_model_resnet50_e5')

learn.unfreeze()
learn.lr_find()
plt.savefig("learning rate")
plt.close()

learn.fit_one_cycle(10, lr_max=slice(1e-7, 5e-7))

learn.recorder.plot_loss()
plt.savefig("loss")
plt.close()
learn.save('trained_model_resnet50')

modelname = learn.model
modelname.cpu()
torch.save(modelname, 'trained_model_resnet50.pkl')

with open(CLASSES_PATH, 'w') as f:
    for item in dls.vocab:
        f.write("%s\n" % item)

plt.plot(L(learn.recorder.values).itemgot(2))
plt.xlabel("Epochs")
plt.ylabel("F-beta Score")
plt.savefig("validation FBeta score")
plt.close()